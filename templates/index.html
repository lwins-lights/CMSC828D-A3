<!DOCTYPE html>
<meta charset="utf-8" />

<head>
  <title>CMSC828D A2 (Yufan Zheng)</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <!--
  <script src="https://unpkg.com/d3-simple-slider"></script>
  <link
  rel="stylesheet"
  href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
  integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
  crossorigin="anonymous"
  />
  -->
</head>

<body>
  <div class="container">
    <h1>CMSC828D A2 (Yufan Zheng)</h1>
    <div id="xygraph">
  </div>
  <script>
    const xygraphMargin = ({top: 20, right: 30, bottom: 30, left: 40});
    const formatValuePrecision = 3;

    function formatValue(x, prec) {
      let l = Math.log10(x);
      if (l <= 0) return x.toFixed(prec);
      if (l > 0 && l <= 3) return x.toFixed(prec - Math.ceil(l));
      if (l > 3 && l <= 6) return (x/1000.0).toFixed(prec + 3 - Math.ceil(l)) + "k";
      if (l > 6 && l <= 9) return (x/1000000.0).toFixed(prec + 6 - Math.ceil(l)) + "m";
      if (l > 9) return (x/1000000000.0).toFixed(prec + 9 - Math.ceil(l)) + "b";
    }

    function renderXygraph(data, xmin, xmax, ymin, ymax, height, width, margin) {
      //clearNode("vis");
      const svg = d3.select("#xygraph").append("svg")
        .attr("width",width)
        .attr("height",height)

      const x = d3.scaleLinear()
        .domain([xmin, xmax]).nice()
        .range([margin.left, width - margin.right]);

      const y = d3.scaleLinear()
        .domain([ymin, ymax]).nice()
        .range([height - margin.bottom, margin.top]);

      const xAxis = (g, x) => g
        .attr("transform", `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(x)
          .tickFormat(d => formatValue(d, formatValuePrecision))
          );

      const yAxis = (g, y) => g
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(y)
          .tickFormat(d => formatValue(d, formatValuePrecision))
          );

      const line = (x, y) => d3.line()
        .defined(d => !isNaN([0]) && !isNaN([1]))
        .x(d => x(d[0]))
        .y(d => y(d[1]));

      const gx = svg.append("g")
        .call(xAxis, x);

      const gy = svg.append("g")
        .call(yAxis, y);

      svg.append("clipPath")
          .attr("id", "xygraph-clip")
        .append("rect")
          .attr("x", margin.left)
          .attr("y", margin.top)
          .attr("width", width - margin.left - margin.right)
          .attr("height", height - margin.top - margin.bottom);
    
      const path = svg.append("path")
        .attr("clip-path", "url(#xygraph-clip)")
        .datum(data)
        .attr("fill", "none")
        .attr("stroke", "steelblue")
        .attr("stroke-width", 5)
        .attr("stroke-linejoin", "round")
        .attr("stroke-linecap", "round")
        .attr("d", line(x, y));

      const zoom = d3.zoom()
        .scaleExtent([1, Infinity])
        .extent([[margin.left, margin.top], [width - margin.right, height - margin.top]])
        .translateExtent([[margin.left, margin.top], [width - margin.right, height - margin.top]])
        .on("zoom", zoomed);

      svg.call(zoom);

      function zoomed(event) {
        //console.log(event);
        const xz = event.transform.rescaleX(x);
        const yz = event.transform.rescaleY(y);
        
        gx.call(xAxis, xz);
        gy.call(yAxis, yz);
        path.attr("d", line(xz, yz));
        //path.attr("transform", event.transform)
      }

      //console.dir(data);
      //console.dir([xmin, xmax, ymin, ymax]);
      return;
    }

    let url = new URL("http://localhost:10007/get-data");
    url.search = new URLSearchParams({"qtype":"data", "country":"United States", "yattr":"gdp_percap", "xattr":"population"}).toString();
    fetch(url,{"credentials": "same-origin"})
    .then(response => response.json())
    .then(fetchedData => {
      let xygraphData = fetchedData["xygraph"];
      let xmin = fetchedData["xmin"], xmax = fetchedData["xmax"], ymin = fetchedData["ymin"], ymax = fetchedData["ymax"];
      renderXygraph(xygraphData, xmin, xmax, ymin, ymax, 500, 500, xygraphMargin);
    });
  </script>
</body>

<!--
<body>
<div class="container">
  <h1>CMSC828D -- A1</h1>
  <div class="row align-items-center">
    <div class="col-sm-2"><span>Attributes:</span></div>
    <div id="attributes">
    </div>
  </div>
  <div class="row align-items-center">
    <div class="col-sm-2"><span>Total Bins:</span><p id="bin-value"></p></div>
    <div class="col-sm"><div id="bin-slider"></div></div>
  </div>
  <div class="row align-items-center">
    <div class="col-sm-2"><span>Filter Range:</span><p id="value-range"></p></div>
    <div class="col-sm"><div id="slider-range"></div></div>
  </div>
  <div id="vis">
</div>

<script>
  const margin = {top: 20, right: 20, bottom: 55, left: 50}; // margins of the visualization (for the axes labels and ticks)
  const height = 300; // height of the visualization
  const width = 800; // width of the visualization
  const prec = 2, lb = 0.001, ub = 1000;
  let currentAttribute = null; // to keep track of the last attribute that was clicked in the interface
  let currentTotalBins = null; // to keep track of numbers of bins
  let num = null; // number of rows; only used for generating scales


  /*
    Convert a real to a scientific notation if it is out of range
    Also control the length of the result
  */
  function convertToSciForm(x) {
    if ((x < lb) || (x > ub)) {
      return x.toExponential(prec);
    } else {
      return x.toFixed(prec);
    }
  }

  /*
    For extracting BinRanges from the aggregated data
    NO COMPUTATION INVOLVED EXCEPT FOR INTERNAL FORMATTING
  */
  function myExtractBinRanges(agg) {
    let binRanges = [];
    for (let i = 0; i < agg.length; i++) {
      binRanges.push({"rangeMin":agg[i][2],"rangeMax":agg[i][3]})
    }
    return binRanges;
  }

  /*
    For extracting BinCounts from BinRanges, which in turn comes from the aggregated data
    NO COMPUTATION INVOLVED EXCEPT FOR INTERNAL FORMATTING
  */
  function myExtractBins(agg,binRanges) {
    let res = [];
    let j = 0;
    for (let i = 0; i < binRanges.length; i++) {
      if ((j < agg.length) && (binRanges[i]["rangeMin"] == agg[j][2])) {
        res.push(agg[j][1]);
        j++;
      } else {
        res.push(0);
      }
    }
    return res;
  }

  // update the current histogram with new binCounts, binRanges is the same
  function updateHistogram(margin,height,width,binCounts, binRanges, x, y) {
    d3.select("#vis svg").selectAll("rect")
      .data(binRanges)
      .join("rect")
        .attr("x", d => x(d.rangeMin) + 1)
        .attr("width", d => Math.max(0, x(d.rangeMax) - x(d.rangeMin) - 1))
        .attr("y", (d,i) => {/*console.log(d); console.log(i.toString());*/ return y(binCounts[i]); })
        .attr("height", (d,i) => y(0) - y(binCounts[i]));
  }
  
  // create a new histogram with new binCounts and binRanges
  function renderHistogram(margin,height,width, binCounts, binRanges) {
    clearNode("vis");
    const svg = d3.select("#vis").append("svg")
      .attr("width",width)
      .attr("height",height);

    let x = d3.scaleLinear()
      .domain([binRanges[0].rangeMin, binRanges[binRanges.length - 1].rangeMax])
      .range([margin.left, width - margin.right]);

    let y = d3.scaleLinear()
      .domain([0, d3.max(binCounts)]).nice()
      .range([height - margin.bottom, margin.top]);

    let y2 = d3.scaleLinear()
      .domain([0, d3.max(binCounts)*currentTotalBins*1.0/num])
      .range([height - margin.bottom, margin.top]);

    let xAxis = g => g
      .attr("transform", `translate(0,${height - margin.bottom})`)
      .call(d3.axisBottom(x).ticks(currentTotalBins))
        .selectAll("text")
        .attr("y", 0)
        .attr("x", 9)
        .attr("dy", ".35em")
        .attr("transform", "rotate(90)")
        .style("text-anchor", "start");

    let yAxis = g => g
      .attr("transform", `translate(${margin.left},0)`)
      .call(d3.axisLeft(y).ticks(10));

    let yAxis2 = g => g
      .attr("transform", `translate(${margin.left},0)`)
      .call(d3.axisRight(y2));

    svg.append("g")
        .attr("fill", "lightsteelblue")
      .selectAll("rect")
      .data(binRanges)
      .join("rect")
        .attr("x", d => x(d.rangeMin) + 1)
        .attr("width", d => Math.max(0, x(d.rangeMax) - x(d.rangeMin) - 1))
        .attr("y", (d,i) => y(binCounts[i]))
        .attr("height", (d,i) => y(0) - y(binCounts[i]));

    svg.append("g")
        .call(xAxis);

    svg.append("g")
        .call(yAxis);

    svg.append("g")
        .call(yAxis2);

    svg.append("text")
      .attr("class", "y label")
      .attr("text-anchor", "end")
      .attr("x", -10)
      .attr("y", 6)
      .attr("dy", ".35em")
      .attr("transform", "rotate(-90)")
      .attr("font-size", "14px")
      .attr("font-family", "sans-serif")
      .text("frequency");

    svg.append("text")
      .attr("class", "y label")
      .attr("text-anchor", "end")
      .attr("x", -10)
      .attr("y", 6)
      .attr("dy", "6.5em")
      .attr("transform", "rotate(-90)")
      .attr("font-size", "14px")
      .attr("font-family", "sans-serif")
      .text("normalized density");

    svg.append("text")
      .attr("class", "x label")
      .attr("text-anchor", "end")
      .attr("x", width)
      .attr("y", height - 15)
      .attr("font-size", "14px")
      .attr("font-family", "sans-serif")
      .text(currentAttribute);
  
    return [x,y];
  }

  // removes the content inside of the given DOM element 
  function clearNode(identifier) {
    const myNode = document.getElementById(identifier);
    myNode.textContent = '';
  }
   

  /*
    Create a slider to filter the data based on certain value ranges
    NO COMPUTATION INVOLVED EXCEPT FOR INTERNAL FORMATTING
  */
  function myCreateRangeSlider(mn,mx,agg,binRanges,x,y) {
    clearNode("slider-range");
    clearNode("value-range");
    let sliderRange = d3
      .sliderBottom()
      .min(mn)
      .max(mx)
      .width(300)
      .ticks(5)
      .default([mn, mx])
      .fill("#2196f3")
      .on("onchange", valRange => {
        d3.select("p#value-range").text(convertToSciForm(valRange[0]) + ' - ' + convertToSciForm(valRange[1]));
        let url2 = new URL("http://localhost:8000/get-data");
        url2.search = new URLSearchParams({"qtype":"data","attr":currentAttribute,"totalbins":currentTotalBins,"rangelo":valRange[0],"rangehi":valRange[1]}).toString();
        fetch(url2,{"credentials": "same-origin"})
        .then(response => response.json())
        .then(fetchedData => {
          agg2 = fetchedData[0];
          binCounts = myExtractBins(agg2,binRanges);
          updateHistogram(margin,height,width,binCounts, binRanges, x, y);
        });
      });
  
    let gRange = d3
      .select("div#slider-range")
      .append("svg")
      .attr("width", 500)
      .attr("height", 100)
      .append("g")
      .attr("transform", "translate(30,30)");
  
    gRange.call(sliderRange);
  
    d3.select("p#value-range").text(
      convertToSciForm(sliderRange.value()[0]) + ' - ' + convertToSciForm(sliderRange.value()[1])
    );
  }

  // creates a button for each data attribute in the retrieved CSV file (movies.csv)
  function createAttributeButtons(data) {
    clearNode("attributes");
    d3.select("#attributes")
      .selectAll("button")
      .data(Object.keys(data[0]))
      .join("button")
      .text(d => d)
      .on("click", (e, attributeName) => {
        currentAttribute = attributeName;
        let filteredData = data.map(d => +d[currentAttribute]);
        let mn = d3.min(filteredData);
        let mx = d3.max(filteredData);
        const totalBins = 10;
        let binRanges = computeBinRanges(mn,mx,totalBins);
        let newBins = computeBins(filteredData,binRanges);
        let scales = renderHistogram(margin,height,width,newBins, binRanges);
        let x = scales[0];
        let y = scales[1];
        createBinsSlider(mn,mx,filteredData);
        createRangeSlider(mn,mx,filteredData,binRanges,x,y);
      });
  }

  /*
    Creates a button for each data attribute
    --------------------------------------------------
    col: list of attributes
  */
  function myCreateAttributeButtons(col) {
    clearNode("attributes");
    d3.select("#attributes")
      .selectAll("button")
      .data(col)
      .join("button")
      .text(d => d)
      .on("click", (e, attributeName) => {
        currentAttribute = attributeName;
        const totalBins = 10;
        currentTotalBins = totalBins;
        let url2 = new URL("http://localhost:8000/get-data");
        url2.search = new URLSearchParams({"qtype":"data","attr":currentAttribute,"totalbins":totalBins,"rangelo":"default","rangehi":"default"}).toString();
        fetch(url2,{"credentials": "same-origin"})
        .then(response => response.json())
        .then(fetchedData => {
          mn = fetchedData[1];
          mx = fetchedData[2];
          agg2 = fetchedData[0];
          let binRanges = myExtractBinRanges(agg2);
          let newBins = myExtractBins(agg2,binRanges);
          let scales = renderHistogram(margin,height,width,newBins,binRanges);
          let x = scales[0];
          let y = scales[1];
          myCreateBinsSlider(mn,mx,agg2);
          myCreateRangeSlider(mn,mx,agg2,binRanges,x,y);
        });
      });
  }

  /*
    Create a slider to modify how many bins are used in the histogram
  */
  function myCreateBinsSlider(mn,mx,agg) {
    clearNode("bin-slider");
    let slider = d3
      .sliderBottom()
      .min(1)
      .max(30)
      .width(300)
      .ticks(5)
      .step(1)
      .default(10)
      .fill("#2196f3")
      .on("onchange", totalBins => {
        d3.select("p#bin-value").text(totalBins);
        let url2 = new URL("http://localhost:8000/get-data");
        url2.search = new URLSearchParams({"qtype":"data","attr":currentAttribute,"totalbins":totalBins,"rangelo":"default","rangehi":"default"}).toString();
        currentTotalBins = totalBins;
        fetch(url2,{"credentials": "same-origin"})
        .then(response => response.json())
        .then(fetchedData => {
          agg2 = fetchedData[0];
          let binRanges = myExtractBinRanges(agg2);
          let binCounts = myExtractBins(agg2,binRanges);
          let scales = renderHistogram(margin,height,width,binCounts, binRanges);
          let x = scales[0];
          let y = scales[1];
          myCreateRangeSlider(mn,mx,agg2,binRanges,x,y);
        });
      });

    let gRange = d3
      .select("div#bin-slider")
      .append("svg")
      .attr("width", 500)
      .attr("height", 100)
      .append("g")
      .attr("transform", "translate(30,30)");

    gRange.call(slider);

    d3.select("p#bin-value").text(
      slider
        .value()
    );
  }

  // initial creation of the attribute buttons, sliders, and histogram
  // fetch enables GET and POST requests to the server (run using server.py)
  
  let url = new URL("http://localhost:8000/get-data");
  url.search = new URLSearchParams({"qtype":"init"}).toString();
  fetch(url,{"credentials": "same-origin"})
  .then(response => response.json())
  .then(fetchedData => {
    let attr = fetchedData["attr"];
    num = fetchedData["num"]
    currentAttribute = attr[0]; // set default attribute
    myCreateAttributeButtons(attr);
    const totalBins = 10;
    currentTotalBins = totalBins;
    let url2 = new URL("http://localhost:8000/get-data");
    url2.search = new URLSearchParams({"qtype":"data","attr":currentAttribute,"totalbins":totalBins,"rangelo":"default","rangehi":"default"}).toString();
    fetch(url2,{"credentials": "same-origin"})
    .then(response => response.json())
    .then(fetchedData => {
      mn = fetchedData[1];
      mx = fetchedData[2];
      agg = fetchedData[0];
      let binRanges = myExtractBinRanges(agg);
      let newBins = myExtractBins(agg,binRanges);
      let scales = renderHistogram(margin,height,width,newBins, binRanges);
      let x = scales[0];
      let y = scales[1];
      myCreateBinsSlider(mn,mx,agg);
      myCreateRangeSlider(mn,mx,agg,binRanges,x,y);
    });
  });
</script>
</body>
-->